use crate::{QosPolicies, TopicKind, TypeDesc};
use crate::io_uring::dds::topic::Topic;
use crate::io_uring::dds::cache::DDSCache;
use crate::io_uring::discovery::DiscoveryDB;
use crate::io_uring::network::UDPSender;
use crate::io_uring::dds::with_key::DataWriter;

use crate::GUID;
use crate::structure::guid::GuidPrefix;
use crate::structure::guid::EntityKind;
use crate::EntityId;

use crate::io_uring::rtps::Domain;
use crate::io_uring::timer::timer_state;
use io_uring_buf_ring::buf_ring_state;
use io_uring::IoUring;

use crate::io_uring::discovery::Discovery2;

pub struct Participant {
    pub guid: GUID,
    entity_id_gen: u32,
    //participant_id: u16,
    //domain_id: u16,
}

impl Participant {
    pub fn new() -> Self {
        let guid = GUID::new_participant_guid();
        let entity_id_gen = 0;
        Self {
            guid,
            entity_id_gen,
        }
    }
}

pub struct TopicComponent<'a> {
    topic: Topic,
    participant: &'a mut Participant,
}

impl Participant {
    pub fn create_topic(&mut self, topic_name: String, type_name: String, qos: &QosPolicies, kind: TopicKind, dds_cache: &mut DDSCache) -> TopicComponent<'_> {
        let typedesc = TypeDesc::new(type_name);
        let topic = Topic::new(topic_name.clone(), typedesc.clone(), qos, kind);

        dds_cache.add_new_topic(topic_name, typedesc, qos);
        TopicComponent {
            topic,
            participant: self,
        }
    }

    fn new_entity_id(&mut self, entity_kind: EntityKind) -> EntityId {
        let [_goldilocks, papa_byte, mama_byte, baby_byte] = self
          .entity_id_gen
          .to_be_bytes();
        self.entity_id_gen += 1;
        EntityId::new([papa_byte, mama_byte, baby_byte], entity_kind)
    }
}

impl TopicComponent<'_> {
    pub fn publisher<'q>(&mut self, qos: &'q QosPolicies) -> Publisher<'_, 'q> {
        Publisher {
            topic: &self.topic,
            participant: self.participant,
            qos,
        }
    }

    pub fn subscriber<'q>(&mut self, qos: &'q QosPolicies) -> Subscriber<'_, 'q> {
        Subscriber {
            topic: &self.topic,
            participant: self.participant,
            qos,
        }
    }
}

pub struct Publisher<'a, 'q> {
    topic: &'a Topic,
    participant: &'a mut Participant,
    qos: &'q QosPolicies,
}

use crate::with_key::SerializerAdapter;
use crate::Keyed;

use crate::CDRSerializerAdapter;
use byteorder::LittleEndian;

impl Publisher<'_, '_> {
    pub fn create_datawriter_cdr<D: Keyed + serde::Serialize>(&mut self, qos: Option<QosPolicies>, discovery_db: &mut DiscoveryDB, domain: &mut Domain<timer_state::Init, buf_ring_state::Init>, ring: &mut IoUring, discovery: &mut Discovery2<timer_state::Init>, udp_sender: &UDPSender) -> DataWriter::<D, CDRSerializerAdapter<D, LittleEndian>> where <D as Keyed>::K: serde::Serialize {
        self.create_datawriter(qos, discovery_db, domain, ring, discovery, udp_sender)
    }
    pub fn create_datawriter<D: Keyed, SA: SerializerAdapter<D>>(&mut self, qos: Option<QosPolicies>, discovery_db: &mut DiscoveryDB, domain: &mut Domain<timer_state::Init, buf_ring_state::Init>, ring: &mut IoUring, discovery: &mut Discovery2<timer_state::Init>, udp_sender: &UDPSender) -> DataWriter::<D, SA> {
        //1) pubsub line 160
        //2) pubsub line 446
        use crate::dds::qos::HasQoSPolicy;
        let writer_qos = self.qos
            .modify_by(&self.topic.qos())
            .modify_by(&qos.unwrap_or(QosPolicies::qos_none()));

        let entity_id = self.participant.new_entity_id(EntityKind::WRITER_WITH_KEY_USER_DEFINED);

        use crate::GUID;
        let guid = GUID::new(self.participant.guid.prefix, entity_id);

        let (datawriter, manual_assertion) = DataWriter::<D, SA>::new(
            self.topic.clone(),
            writer_qos.clone(),
            guid,
        );



        use crate::discovery::DiscoveredWriterData;
        let discovered_data = DiscoveredWriterData::new_io_uring(&datawriter, self.topic, domain.domain_info.domain_id, domain.domain_info.participant_id, self.participant.guid, None, );

        discovery_db.update_local_topic_writer(discovered_data);
        discovery_db.update_topic_data_p(self.topic);

        use crate::io_uring::dds::topic::TopicDescription;

        let writer_like_stateless = false;
        use crate::io_uring::rtps::{Writer, WriterIngredients};
        let writer_ing = WriterIngredients {
            guid,
            topic_name: self.topic.name(),
            like_stateless: writer_like_stateless,
            qos_policies: writer_qos,
            security_plugins: None,
        };

        domain.add_local_writer(writer_ing, ring).unwrap();

        discovery.publish_writer(guid, discovery_db, udp_sender, ring);
        discovery.publish_topic(&self.topic.name(), discovery_db, udp_sender, ring);

        if manual_assertion {
            discovery.liveliness_state.manual_participant_liveness_refresh_requested = true;
        }
        datawriter
    }
}

struct Subscriber<'a, 'q> {
    topic: &'a Topic,
    participant: &'a mut Participant,
    qos: &'q QosPolicies,
}

use crate::with_key::DeserializerAdapter;
use crate::io_uring::dds::with_key::SimpleDataReader;
impl Subscriber<'_, '_> {


    fn create_simple_datareader<D: Keyed + 'static, SA: DeserializerAdapter<D>>(&mut self, qos: Option<QosPolicies>, dds_cache: &mut DDSCache, discovery_db: &mut DiscoveryDB, domain: &mut Domain<timer_state::Init, buf_ring_state::Init>, ring: &mut IoUring, discovery: &mut Discovery2<timer_state::Init>, udp_sender: &UDPSender) -> SimpleDataReader<D, SA> {
        // pubsub line 786
        // pubsub line 1216
        // pubsub line 986
        // pubsub line 1010

        use crate::dds::qos::HasQoSPolicy;
        let reader_qos = self.qos
            .modify_by(&self.topic.qos())
            .modify_by(&qos.unwrap_or(QosPolicies::qos_none()));

        let entity_id = self.participant.new_entity_id(EntityKind::WRITER_WITH_KEY_USER_DEFINED);

        use crate::GUID;
        let guid = GUID::new(self.participant.guid.prefix, entity_id);

        use crate::io_uring::dds::topic::TopicDescription;

        let topic_cache = dds_cache.get_existing_topic_cache(&self.topic.name()).unwrap();
        topic_cache.update_keep_limits(&reader_qos);

        // locators are in messagereceiver for rtps reader proxy.



        /*
        use crate::discovery::DiscoveredWriterData;
        let discovered_data = DiscoveredWriterData::new_io_uring(&datawriter, self.topic, domain.domain_info.domain_id, domain.domain_info.participant_id, self.participant.guid, None);

        discovery_db.update_local_topic_writer(discovered_data);
        discovery_db.update_topic_data_p(self.topic);
        */


        let reader_like_stateless = false;
        use crate::io_uring::rtps::ReaderIngredients;
        let reader_ing = ReaderIngredients {
            guid,
            topic_name: self.topic.name(),
            like_stateless: reader_like_stateless,
            qos_policy: reader_qos.clone(),
            security_plugins: None,
        };

        let crate::io_uring::discovery::traffic::UserTrafficLocators {
            unicast_user_traffic,
            multicast_user_traffic,
        } = domain.listeners.user_traffic_locators();

        let proxy = crate::io_uring::rtps::RtpsReaderProxy::new(guid, reader_qos.clone(), unicast_user_traffic, multicast_user_traffic);



        //discovery_db.update_local_topic_reader(&(), self.topic, &reader_ing, None);
        discovery_db.update_topic_data_p(self.topic);

        domain.add_local_reader(reader_ing, ring).unwrap();

        discovery.publish_writer(guid, discovery_db, udp_sender, ring);
        discovery.publish_topic(&self.topic.name(), discovery_db, udp_sender, ring);

        SimpleDataReader::new(guid.prefix, guid.entity_id, self.topic.clone(), reader_qos).unwrap()
    }
}
